1、二分法中点计算问题
 1. int mid = l + (r - l) / 2;
 2. int mid = (l + r) / 2;
 在数学上，这两种表达式是等价的，因为：l + (r - l) / 2 = (2l + r - l) / 2 = (l + r) / 2
 但是，在编程中，它们可能因为整数溢出的问题而产生不同的结果。
 考虑当 l 和 r 都是很大的正整数，且 l + r 的值超过了 int 类型的最大值（例如，在32位系统中，int的最大值是2147483647）时：
 第一种写法：l + (r - l) / 2
      先计算 (r - l) 可能是一个较小的数（如果r比l大得不多的话），然后除以2，再加上l。这样不会溢出，只要r>=l（在二分中通常如此）且r和l都是正数，但即使有负数，只要r-l不溢出，那么整个表达式也不会溢出。然而，如果r和l都是负数且绝对值很大，那么r-l也可能溢出（例如r=-2,000,000,000，l=-2,100,000,000，则r-l=100,000,000，不会溢出；但如果r和l都是很大的负数，且l比r小很多，那么r-l可能是一个很大的正数，但这种情况在二分中通常不会出现，因为二分要求l<=r）。实际上，在二分查找中，我们通常有l<=r，所以r-l>=0且不会大于r（如果r是正数）或l（如果l是负数）的绝对值。但无论如何，第一种写法比第二种更安全。
  第二种写法：(l + r) / 2
      先计算 l + r，如果l和r都很大，那么l+r可能会超出int的范围，导致溢出（变成负数或者错误的正数），然后再除以2，结果就是错误的。

2、(long long)mid * mid <= x 解释
int mid, x;
(long long)mid 将第一个 mid 强制转换为 long long 类型。
根据 C/C++ 的隐式类型转换规则，第二个 mid 也会被自动提升为 long long。
乘法在 long long 类型下进行，确保大数乘积不会溢出。
等价于 (long long)mid * (long long)mid
在大小比较中，编译器会将较小的类型提升到较大的类型。
